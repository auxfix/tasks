// Общие вопросы

// 1. Расскажите о себе. Опыте.
// 2. Самое любимое место.
// 3. С какими процессами приходилось сталкиватся.
// 3. Почему именно фронтенд.
// 4. Что больше всего нравится в работе.
// 6. Что больше всего раздражает.

// HTML

// 1. Что такое семантика.(SEO, Special Needs, Text Readers).
//    Почему бы не верстать на одних дивах.
// 2. Flex/Grid - основные свойства.

// display: flex; — элемент становится flex-контейнером.
// flex-direction — определяет направление расположения flex-элементов:
// flex-wrap — определяет, будут ли flex-элементы переноситься на новую строку/колонку, если они не помещаются в одном ряду/колонке:
// justify-content — выравнивание элементов по главной оси:
// align-items — выравнивание элементов по поперечной оси:
// align-content — выравнивание множественных строк flex-элементов по поперечной оси (работает, только если задействовано свойство flex-wrap): 

// display: grid; — элемент становится grid-контейнером.
// grid-template-columns — определяет количество и размеры столбцов в сетке.
// grid-template-rows — определяет количество и размеры строк в сетке.
// grid-template-areas — позволяет именовать области сетки для упрощенного позиционирования элементов.
// grid-column-gap и grid-row-gap (или gap) — задают расстояние между колонками и строками, соответственно.
// justify-items — выравнивание элементов по горизонтали внутри их сеточных ячеек:
// align-items — выравнивание элементов по вертикали внутри их сеточных ячеек. 


// 3. Box-model
// Content (Контент): В плане CSS это область, где отображаются текст, изображения или другие медиа.
// Padding (Отступ): Пространство между контентом и границей (border). Оно увеличивает внутреннее пространство элемента, создавая больше места вокруг контента.
// Border (Граница): Линия, которая окружает отступ и контент. Она выделяет границы элемента, делая его более явным.
// Margin (Поле): Внешнее пространство за границей элемента. Это пространство отделяет элемент от других элементов на странице, влияя на внешний зазор между элементами.


// 4. box-sizing

// box-sizing: content-box;  Указывает ширину и высоту только для области контента.
// box-sizing: border-box;  Размеры: Указывает ширину и высоту для всего элемента (контент + padding + border).

// 5. Критический путь рендеринга (Critical Rendering Path) — это последовательность шагов, которые браузер выполняет для отображения веб-страницы на экране. Включает в себя следующие этапы:

//     Загрузка HTML:
//         Чтение HTML-документа и создание DOM (Document Object Model).
//     Загрузка CSS:
//         Загрузка и разбор CSS для построения CSSOM (CSS Object Model).
//     Загрузка JavaScript:
//         Выполнение JavaScript, который может изменить DOM/CSSOM.
//     Строительство рендер-дерева:
//         Объединение DOM и CSSOM для создания рендер-дерева.
//     Layout (вычисление размеров и положений):
//         Вычисление геометрии элементов на странице.
//     Покраска (Paint):
//         Рендеринг пикселей на экране.

//     Async/Defer    

// Оптимизация критического пути рендеринга сокращает время до первого полезного отображения (First Meaningful Paint), улучшая пользовательский опыт.


// 6. JavaScript. EventLoop. Однопоточный или многопоточный?
// setTimeout, setInterval, setImmediate, requestAnimationFrame, I/O,  - macrotasks 

// process.nextTick, Promises, Object.observe, MutationObserver - microtasks 


// 7. TypeScript
//  Зачем он? Может лучше без него?
//  Что такое Generic, приходилось ли писать
//  void vs never

// 8. React
// - Классы Vs Функции. Разница. Зачем вообще придумали функции? Почему бы не остатся на классах?
// - Основные хуки:
// useState: Позволяет добавлять локальное состояние в функциональные компоненты.
// useEffect: Управляет побочными эффектами, такими как запросы к API или подписки на события.
// useContext: Получает значение контекста без использования Consumer, упрощая доступ к глобальному состоянию.
// useReducer: Используется для сложного управления состоянием, позволяет писать логики, подобные Redux.
// useCallback: Мемоизирует функции, предотвращает их пересоздание при каждом рендере, если зависимости не изменились.
// useMemo: Мемоизирует вычисленные значения, экономит ресурсы, пересчитывая их только при изменении зависимостей.
// useRef: Создаёт объект, хранящий изменяемое значение, которое не вызывает повторный рендер при обновлении.
// useImperativeHandle: Позволяет настройка экземпляра компонента, переопределяя значения, доступные через ref.
// useLayoutEffect: Похож на useEffect, но срабатывает синхронно после всех изменений DOM, перед тем как браузер перерисует.
// useDebugValue: Позволяет отображать метаданные о пользовательских хуках в инструментах разработчика React. 
//  - Чем useLayoutEffet отличается от useEffect.
//  - Правила хуков:
//  -- Вызывайте хуки только на верхнем уровне.
//  -- Вызывайте хуки только из функциональных компонентов или пользовательских хуков.
//  -- Название пользовательских хуков должно начинаться с "use".(а обязательно, будет работать без use?)

// 9. SSR 
// - SEO
// - PERFORMANCE(server)
// - user experience

// 10. Next.js
// - Приходилось ли работать
// - 12\13
// - Плюсы минусы 

// 11. - Styled Componennents
//     - отношение, плюсы минусы.